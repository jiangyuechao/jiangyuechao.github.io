<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2022/06/10/Redis%E7%BC%93%E5%AD%98/"/>
      <url>/2022/06/10/Redis%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">redis缓存穿透</span><br><span class="line"><span class="code">    你所要查询的key并不存在于redis缓存中，这时又有大连的请求查询这个key，就会使得数据库负载过大，就像是穿过了缓存直接击中数据库，很容易把数据库给打挂了</span></span><br><span class="line"><span class="code">    解决方案：</span></span><br><span class="line"><span class="code">        第一种方法呢就是数据库查询不到的key直接保存在redis中，再次查询数据库的时候，缓存层直接返回空</span></span><br><span class="line"><span class="code">        第二种方法就涉及到了一个叫布隆过滤器的东西，本质上是一个二进制数组，以空间换时间，以低内存空间解决缓存穿透的问题，将所有存在的key提前存入布隆过滤器，在请求进入缓存之前，布隆过滤器进行拦截，若不存在直接返回空</span></span><br><span class="line"><span class="code">        </span></span><br><span class="line"><span class="code">redis缓存击穿</span></span><br><span class="line"><span class="code">    某一个热点的key失效了，大量的请求直接到达数据库</span></span><br><span class="line"><span class="code">    解决方法：</span></span><br><span class="line"><span class="code">        第一种设置永不过期</span></span><br><span class="line"><span class="code">        第二种就是加互斥锁，互斥锁就是同一时刻只有一个线程能够进行访问，加了互斥锁之后第一个访问完后，缓存中的数据将会被重建，之后直接从缓存中取就可以了</span></span><br><span class="line"><span class="code">        </span></span><br><span class="line"><span class="code">redis缓存雪崩</span></span><br><span class="line"><span class="code">    可能是redis宕机了，也可能是有很多key设置了统一过期时间</span></span><br><span class="line"><span class="code">    解决方案：</span></span><br><span class="line"><span class="code">        第一种构建高可用的Redis缓存：搭建Redis集群，提高Redis的容灾性</span></span><br><span class="line"><span class="code">        第二种使用熔断机制：对存储层增加限流措施，当请求超出限制时，对其提供降级措施，例如：当请求到达一定阈值，直接返回“系统繁忙“等提示，防止过多的请求到达数据库上，这样可以保证一部分用户还可以使用，其他用户多刷新几次也能得到结果</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
